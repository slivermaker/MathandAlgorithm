# æœç´¢

## æ¡†æ¶

### *dfsæ¡†æ¶*

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100005;
struct Node {
    char value;   int lson, rson;
} tree[N];                     //tree[0]ä¸ç”¨ï¼Œ0è¡¨ç¤ºç©ºç»“ç‚¹
int index = 1;                 //è®°å½•ç»“ç‚¹å­˜åœ¨tree[]çš„ä½ç½®ï¼Œä»tree[1]å¼€å§‹ç”¨
int newNode(char val) {        //æ–°å»ºç»“ç‚¹
    tree[index].value = val;
    tree[index].lson = 0;     //0è¡¨ç¤ºç©ºï¼Œtree[0]ä¸ç”¨
    tree[index].rson = 0;
    return index ++;
}
void insert(int &father, int child, int l_r) { //æ’å…¥å­©å­
    if (l_r == 0) tree[father].lson = child;  //å·¦å­©å­
    else         tree[father].rson = child;   //å³å­©å­
}
int dfn[N] = {0};              //dfn[i]æ˜¯ç»“ç‚¹içš„æ—¶é—´æˆ³
int dfn_timer = 0;
void dfn_order (int father) {
    if (father != 0) {
        dfn[father] = ++dfn_timer;
        printf("dfn[%c]=%d; ", tree[father].value, dfn[father]);//æ‰“å°æ—¶é—´æˆ³
        dfn_order (tree[father].lson);
        dfn_order (tree[father].rson);
    }
}
int visit_timer = 0;
void visit_order (int father) {       //æ‰“å°DFSåº
    if (father != 0) {
        printf("visit[%c]=%d; ", tree[father].value, ++visit_timer);
        //æ‰“å°DFSåºï¼šç¬¬1æ¬¡è®¿é—®ç»“ç‚¹
        visit_order (tree[father].lson);
        visit_order (tree[father].rson);
        printf("visit[%c]=%d; ", tree[father].value, ++visit_timer);
        //æ‰“å°DFSåºï¼šç¬¬2æ¬¡å›æº¯
    }
}
int deep[N] = {0};                    //deep[i]æ˜¯ç»“ç‚¹içš„æ·±åº¦
int deep_timer = 0;
void deep_node (int father) {
    if (father != 0) {
        deep[father] = ++deep_timer;  //æ‰“å°æ ‘çš„æ·±åº¦ï¼Œç¬¬ä¸€æ¬¡è®¿é—®æ—¶ï¼Œæ·±åº¦+1
        printf("deep[%c]=%d; ", tree[father].value, deep[father]);
        deep_node (tree[father].lson);
        deep_node (tree[father].rson);
        deep_timer--;                 //å›æº¯æ—¶ï¼Œæ·±åº¦-1
    }
}
int num[N] = {0};        //num[i]æ˜¯ä»¥iä¸ºçˆ¶äº²çš„å­æ ‘ä¸Šçš„ç»“ç‚¹æ€»æ•°
int num_node (int father) {
    if (father == 0)  return 0;
    else {
        num[father] = num_node (tree[father].lson) +
                      num_node (tree[father].rson) + 1;
        printf("num[%c]=%d; ", tree[father].value, num[father]); //æ‰“å°æ•°é‡
        return num[father];
    }
}
void preorder (int father) {                //æ±‚å…ˆåºåºåˆ—
    if (father != 0) {
        cout << tree[father].value << " ";  //å…ˆåºè¾“å‡º
        preorder (tree[father].lson);
        preorder (tree[father].rson);
    }
}
void inorder (int father) {                  //æ±‚ä¸­åºåºåˆ—
    if (father != 0) {
        inorder (tree[father].lson);
        cout << tree[father].value << " ";   //ä¸­åºè¾“å‡º
        inorder (tree[father].rson);
    }
}
void postorder (int father) {                //æ±‚ååºåºåˆ—
    if (father != 0) {
        postorder (tree[father].lson);
        postorder (tree[father].rson);
        cout << tree[father].value << " ";   //ååºè¾“å‡º
    }
}
int buildtree() {                            //å»ºä¸€æ£µæ ‘
    int A = newNode('A'); int B = newNode('B'); int C = newNode('C'); //å®šä¹‰ç»“ç‚¹
    int D = newNode('D'); int E = newNode('E'); int F = newNode('F');
    int G = newNode('G'); int H = newNode('H'); int I = newNode('I');
    insert(E, B, 0);  insert(E, G, 1);      //å»ºæ ‘ã€‚Eçš„å·¦å­©å­æ˜¯Bï¼Œå³å­©å­æ˜¯G
    insert(B, A, 0);  insert(B, D, 1);  insert(G, F, 0);  insert(G, I, 1);
    insert(D, C, 0);  insert(I, H, 0);
    int root = E;
    return root;
}
int main() {
    int root = buildtree();
    cout << "dfn order: ";     dfn_order(root); cout << endl;   //æ‰“å°æ—¶é—´æˆ³
    cout << "visit order: "; visit_order(root); cout << endl;   //æ‰“å°DFSåº
    cout << "deep order: ";    deep_node(root); cout << endl;   //æ‰“å°ç»“ç‚¹æ·±åº¦
    cout << "num of tree: ";    num_node(root); cout << endl;   //æ‰“å°å­æ ‘ä¸Šçš„ç»“ç‚¹æ•°
    cout << "in order:   ";      inorder(root); cout << endl;   //æ‰“å°ä¸­åºåºåˆ—
    cout << "pre order:  ";     preorder(root); cout << endl;   //æ‰“å°å…ˆåºåºåˆ—
    cout << "post order: ";    postorder(root); cout << endl;   //æ‰“å°ååºåºåˆ—
    return 0;
}
/*   è¾“å‡ºæ˜¯ï¼š
dfn order: dfn[E]=1; dfn[B]=2; dfn[A]=3; dfn[D]=4; dfn[C]=5; dfn[G]=6; dfn[F]=7; dfn[I]=8; dfn[H]=9;
visit order: visit[E]=1; visit[B]=2; visit[A]=3; visit[A]=4; visit[D]=5; visit[C]=6; visit[C]=7; visit[D]=8; visit[B]=9; visit[G]=10; visit[F]=11; visit[F]=12; visit[I]=13; visit[H]=14; visit[H]=15; visit[I]=16; visit[G]=17; visit[E]=18;
deep order: deep[E]=1; deep[B]=2; deep[A]=3; deep[D]=3; deep[C]=4; deep[G]=2; deep[F]=3; deep[I]=3; deep[H]=4;
num of tree: num[A]=1; num[C]=1; num[D]=2; num[B]=4; num[F]=1; num[H]=1; num[I]=2; num[G]=4; num[E]=9;
in order:   A B C D E F G H I
pre order:  E B A D C G F I H
post order: A C D B F H I G E    */

```

### *bfsæ¡†æ¶*

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100005;
struct Node {                 //ç”¨é™æ€æ•°ç»„è®°å½•äºŒå‰æ ‘
    char value;
    int lson, rson;           //å·¦å³å­©å­
} tree[N];                    //tree[0]ä¸ç”¨ï¼Œ0è¡¨ç¤ºç©ºç»“ç‚¹
int index = 1;                //è®°å½•ç»“ç‚¹å­˜åœ¨tree[]çš„ä½ç½®ï¼Œä»tree[1]å¼€å§‹ç”¨
int newNode(char val) {
    tree[index].value = val;
    tree[index].lson = 0;     //0è¡¨ç¤ºç©ºï¼Œtree[0]ä¸ç”¨
    tree[index].rson = 0;
    return index ++;
}
void Insert(int &father, int child, int l_r) {   //æ’å…¥å­©å­
    if (l_r == 0)  tree[father].lson = child;    //å·¦å­©å­
    else          tree[father].rson = child;     //å³å­©å­
}
int buildtree() {             //å»ºä¸€æ£µäºŒå‰æ ‘
    int A = newNode('A'); int B = newNode('B'); int C = newNode('C');
    int D = newNode('D'); int E = newNode('E'); int F = newNode('F');
    int G = newNode('G'); int H = newNode('H'); int I = newNode('I');
    Insert(E, B, 0);  Insert(E, G, 1);   //Eçš„å·¦å­©å­æ˜¯Bï¼Œå³å­©å­æ˜¯G
    Insert(B, A, 0);  Insert(B, D, 1);
    Insert(G, F, 0);  Insert(G, I, 1);
    Insert(D, C, 0);  Insert(I, H, 0);
    int root = E;
    return root;
}
int main() {
    int root = buildtree();
    queue <int> q;
    q.push(root);                          //ä»æ ¹ç»“ç‚¹å¼€å§‹
    while (q.size()) {
        int tmp = q.front();
        cout << tree[tmp].value << " ";    //æ‰“å°é˜Ÿå¤´
        q.pop();                           //å»æ‰é˜Ÿå¤´
        if (tree[tmp].lson != 0) q.push(tree[tmp].lson);  //å·¦å­©å­å…¥é˜Ÿ
        if (tree[tmp].rson != 0) q.push(tree[tmp].rson);  //å³å­©å­å…¥é˜Ÿ
    }
    return 0;
}
```

## ç”¨é€”

**å‰ªæ è®°å¿†åŒ–dfs åŒå‘bfs è¿­ä»£åŠ dfs A - starbfs IDAdfs**

### **è¿é€šæ€§é—®é¢˜**

#### ä»¥è“æ¡¥ã€Šå…¨çƒå˜æš–é—®é¢˜ã€‹

##### dfs

```cpp
const int N;
int mp[N][N];
int vis[N][N];
int d[4][2] = {{0, 1}, {0, -1}, {1, 0}, { -1, 0}};
int flag;
void dfs(int x, int y) {
    vis[x][y] = 1;
    if ( mp[x][y + 1] == '#' && mp[x][y - 1] == '#' &&
            mp[x + 1][y] == '#' && mp[x - 1][y] == '#'   )
        flag = 1;//æœ‰ä¸€æ¬¡èƒ½æŠŠflagå˜æˆä¸€å°±è¯æ˜ä¸ä¼šè¢«æ·¹æ²¡
    for (int i = 0; i < 4; i++) {
        int mx = x + d[i][0], my = y + d[i][1];
        if (vis[mx][my] == 0 && mp[mx][my] == '#') //æ³¨æ„ä¸ºä»€ä¹ˆè¦åˆ¤æ–­vis[][]
            //ç»§ç»­DFSæœªæœè¿‡çš„é™†åœ°ï¼Œç›®çš„æ˜¯æ ‡è®°å®ƒä»¬
            dfs(mx, my);//è¿™ä¸ª#å‘¨å›´æ‰€æœ‰çš„#
    }
}
int main() {
    int n;    cin >> n;
    for (int i = 0; i < n; i++)   cin >> mp[i];
    int ans = 0 ;
    for (int i = 1; i <= n; i++)        //DFSæ‰€æœ‰åƒç´ ç‚¹
        for (int j = 1; j <= n; j++)
            if (mp[i][j] == '#' && vis[i][j] == 0) {//vis[][]ä¼šæ’é™¤å·²ç»æœè¿‡çš„ç‚¹è®°å¿†åŒ–çš„æ„Ÿè§‰
                flag = 0;               //å‡è®¾è¿™ä¸ªå²›è¢«æ·¹
                dfs(i, j);              //æ‰¾è¿™ä¸ªå²›ä¸­æœ‰æ²¡æœ‰é«˜åœ°ï¼Œå¦‚æœæœ‰,ç½®flag=1
                if (flag == 0)  ans++;  //è¿™ä¸ªå²›è¢«æ·¹äº†ï¼Œç»Ÿè®¡è¢«æ·¹æ²¡å²›çš„æ•°é‡
            }
    cout << ans << endl;
    return 0;
}
```
##### bfs

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
char mp[N][N];
int vis[N][N];
int d[4][2] = {{0, 1}, {0, -1}, {1, 0}, { -1, 0}}; //å››ä¸ªæ–¹å‘
int flag;
void bfs(int x, int y) {
    queue<pair<int, int>> q;
    q.push({x, y});
    vis[x][y] = 1;      //æ ‡è®°è¿™ä¸ª'#'è¢«æœè¿‡
    while (q.size()) {
        pair<int, int> t = q.front();
        q.pop();
        int tx = t.first, ty = t.second;
        if ( mp[tx][ty + 1] == '#' && mp[tx][ty - 1] == '#' &&
                mp[tx + 1][ty] == '#' && mp[tx - 1][ty] == '#'   )
            flag = 1; //ä¸Šä¸‹å·¦å³éƒ½æ˜¯é™†åœ°ï¼Œä¸ä¼šæ·¹æ²¡
        for (int i = 0; i < 4; i++) {    //æ‰©å±•(tx,ty)çš„4ä¸ªé‚»å±…
            int nx = tx + d[i][0], ny = ty + d[i][1];
            if (vis[nx][ny] == 0 && mp[nx][ny] == '#') { //æŠŠé™†åœ°æ”¾è¿›é˜Ÿåˆ—
                vis[nx][ny] = 1;  //æ³¨æ„ï¼šè¿™ä¸€å¥å¿…ä¸å¯å°‘
                q.push({nx, ny});
            }
        }
    }
}
int main() {
    int n;  cin >> n;
    for (int i = 0; i < n; i++)    cin >> mp[i];
    int ans = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            if (mp[i][j] == '#' && vis[i][j] == 0) {
                flag = 0;
                bfs(i, j);
                if (flag == 0) ans++; //è¿™ä¸ªå²›å…¨éƒ¨è¢«æ·¹ï¼Œç»Ÿè®¡å²›çš„æ•°é‡
            }
    cout << ans << endl;
    return 0;
}

```
#### å²›å±¿æ•°é‡é—®é¢˜

![image-20221111210908267](D:\sublimeC++\ç¬”è®°\å¤‡æˆ˜æµå—ç«™\æœç´¢\image-20221111210908267.png)

##### dfs

```java
class Solution {
    boolean vis[][];//å¯ä»¥åŸæ•°ç»„ç»è¿‡ä¹‹åå†™æˆ0ä¹Ÿå¯ä»¥å†™ä¸€ä¸ªvis
    int res=0;
    int len1,len2;
    int add[][]=new int[][]{{1,0},{-1,0},{0,1},{0,-1}};//åˆ«å’Œcppçš„å£°æ˜æ–¹æ³•å¼„æ··äº†
    public int numIslands(char[][] grid) {
        len1=grid.length;
        len2=grid[0].length;//æ³¨æ„æ˜¯é•¿åº¦[0].length
        vis=new boolean[len1][len2];//æˆå‘˜å˜é‡åˆå§‹åŒ–
         for(int i=0;i<len1;++i)
            for(int j=0;j<len2;++j){
                if(grid[i][j]=='1'&&!vis[i][j]){//vis[]è¿‡çš„'1'ä¸å†åŠ 
                    res+=1;
                 System.out.println(i+" "+j);//testä¸€ä¸‹
                    dfs(grid,i,j);//ä»ä¸€ä¸ªæ–°å²›å±¿å¼€å§‹æœç´¢
                    
                }
            }
        return res;
    }
    void dfs(char mp[][],int x,int y){
        if(uncheck(mp,x,y))return;//åœ¨æ•°ç»„ä¹‹å¤–ç›´æ¥æ’é™¤
        vis[x][y]=true;//æ²¡æœ‰åˆ«æ’é™¤ä¸”å·²ç»è¢«æœç´¢visä¸€ä¸‹
        for(int i=0;i<4;i++){//å››ä¸ªæ–¹å‘æœç´¢ä¸€ä¸‹
           int nx=x+add[i][0],ny=y+add[i][1];//æ–°åæ ‡ï¼Œæœ€å¥½nx nyæ–¹ä¾¿è§‚å¯Ÿï¼Œä½†ä¸€å®šæ³¨æ„åé¢æ˜¯ä¸æ˜¯åº”è¯¥ç”¨nx nyä¸èƒ½å¤šç”¨ä¹Ÿä¸èƒ½å°‘ç”¨
            if(!uncheck(mp,nx,ny)&&mp[nx][ny]=='1'&&!vis[nx][ny]){//æ•°ç»„å†… æ˜¯é™†åœ°1 æ²¡æœ‰æœç´¢è¿‡ 
            
            dfs(mp,nx,ny);
        }
        }
    }
    boolean uncheck(char mp[][],int x,int y){//åˆ¤æ–­æ˜¯å¦æ•°ç»„å†…
        return x<0||y<0||x>=len1||y>=len2;
    }
}
```



##### bfs

```java
class Solution {
    static boolean vis[][];
    static Queue<int[]>q;//Queue  æœ€å¸¸è§ç”¨LinkedListå®ç°
    static int add[][]=new int[][]{{1,0},{-1,0},{0,1},{0,-1}};//è¿™ç§å†™æ³•ä¸€å®šè¦æ³¨æ„é€—å·
    static int len1,len2;
    public int numIslands(char[][] grid) {
        q=new LinkedList<>();
        len1=grid.length;
        len2=grid[0].length;
        int res=0;
        vis=new boolean[len1][len2];
        for(int i=0;i<len1;i++)
            for(int j=0;j<len2;j++){
                if(grid[i][j]=='1'&&!vis[i][j]){
                 q.offer(new int[]{i,j});
                 vis[i][j]=true;//ä¸€è¿›é˜Ÿåˆ—ç›´æ¥æ ‡æ³¨
                    bfs(grid,i,j);
                    System.out.println(i+" "+j);
                    res++;
                }
            }
            return res;
    }
    void bfs(char mp[][],int x,int y){
        while(!q.isEmpty()){
            int[]tmp=q.poll();//ä¸cppä¸åŒä»–ä¼šç›´æ¥è¹¦å‡ºæ¥
            x=tmp[0];y=tmp[1];
            for(int i=0;i<4;i++){
            int nx=x+add[i][0],ny=y+add[i][1];

            if(check(mp,nx,ny)&&!vis[nx][ny]&&mp[nx][ny]=='1'){
                vis[nx][ny]=true;
                q.offer(new int[]{nx,ny});
            }
            }
        }
        
    }
    boolean check(char[][] mp,int nx,int ny){
        return nx>=0&&ny>=0&&nx<len1&&ny<len2;
    }
}
```

#### å²›å±¿å‘¨é•¿é—®é¢˜

##### dfs

```java
class Solution {
    static int len1,len2;
    static boolean vis[][];
    static int add[][]=new int[][]{{0,1},{0,-1},{1,0},{-1,0}};
    int res=0;//è¿™ä¸ªä¸èƒ½è®¾ç½®æˆstatic
    public int islandPerimeter(int[][] grid) {
        len1=grid.length;
        len2=grid[0].length;
        vis=new boolean[len1][len2];
        for(int i=0;i<len1;i++){
            for(int j=0;j<len2;j++){
                if(!vis[i][j]&&grid[i][j]==1){
                    vis[i][j]=true;
                    dfs(grid,i,j);
                }
            }
        }
        return res;
    }
    void dfs(int mp[][],int x,int y){
        
        
        for(int i=0;i<4;i++){
            int nx=x+add[i][0];int ny=y+add[i][1];
            if(!check(nx,ny)){
                System.out.println(nx+" "+ny);//æµ‹è¯•ä¸€ä¸‹
                res++;continue;}//é‡åˆ°è¾¹ç•Œå‘¨é•¿åŠ ä¸€
            if(mp[nx][ny]==0){res++;continue;}//é‡åˆ°0å‘¨é•¿åŠ ä¸€
            if(!vis[nx][ny]){
                vis[nx][ny]=true;
                dfs(mp,nx,ny); 
            }
                           
        }
    }
    boolean check(int x,int y){
        return x>=0&&y>=0&&x<len1&&y<len2;
    }
}
```

### **å‰ªæ**

#### *bfsåˆ¤é‡*

##### è“æ¡¥ã€Šè·³èš±èœ¢ã€‹å…«æ•°ç é—®é¢˜

012345678â€”â€” > 087654321
æ¯å±‚æ‰©å±•å°±æ˜¯èš±èœ¢è·³ä¸€æ¬¡
æ¯æ¬¡å››ç§è·³æ³•ï¼ˆéš” * 2 + ä¸éš” * 2ï¼‰åˆ¤é‡ä¹‹ååªæœ‰9ï¼

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node {
    node() {}
    node(string ss, int tt) {s = ss, t = tt;}
    string s;
    int t;
};
//(1) map
map<string, bool> mp;
//(2) set
// set<string> visited;    //è®°å½•å·²ç»æœç´¢è¿‡çš„çŠ¶æ€
queue<node> q;
void solve() {
    while (!q.empty()) {
        node now = q.front();
        q.pop();
        string s = now.s;
        int step = now.t;
        if (s == "087654321") { cout << step << endl; break;} //åˆ°ç›®æ ‡äº†ï¼Œè¾“å‡ºè·³è·ƒæ­¥æ•°
        int i;
        for (i = 0 ; i < 10 ; i++)              //æ‰¾åˆ°ç›˜å­çš„ä½ç½®i
            if (s[i] == '0')  break;
        for (int j = i - 2 ; j <= i + 2 ; j++) { //4ç§è·³æ³•
            int k = (j + 9) % 9;
            if (k == i)  continue;              //è¿™æ˜¯å½“å‰çŠ¶æ€ï¼Œä¸ç”¨æ£€æŸ¥
            string news = s;
            char tmp = news[i];
            news[i] = news[k];
            news[k] = tmp;  //è·³åˆ°ä¸€ç§æƒ…å†µ
//(1) map
            if (!mp[news]) {               //åˆ¤é‡ï¼šè¿™ä¸ªæƒ…å†µæ²¡æœ‰å‡ºç°è¿‡
                mp[news] = true;
                q.push(node(news, step + 1));
            }
//(2)set
            /*          if(visited.count(news)==0){    //åˆ¤é‡ï¼šè¿™ä¸ªæƒ…å†µæ²¡æœ‰å‡ºç°è¿‡
                            visited.insert(news);
                            q.push(node(news, step + 1));
                        }      */
        }
    }
}
int main() {
    string s = "012345678";
    q.push(node(s, 0));
//(1) map
    mp[s] = true;
    solve();
    return 0;
}

```
è¿‡ä¼šè¡¥å……Javaå†™æ³•
```java
```

### **æ´ªæ°´å¡«å……**

### ***bfsä¸æœ€çŸ­è·¯***

##### lanqiaoçš„è¿·å®«

```cpp

#include<bits/stdc++.h>
using namespace std;
struct node {
    int x;
    int y;
//(1)ç®€å•æ–¹æ³•ï¼š
    string path;  //path,è®°å½•ä»èµ·ç‚¹(0,0)åˆ°è¿™ä¸ªç‚¹(x,y)çš„å®Œæ•´è·¯å¾„
};
char mp[31][51];  //å­˜åœ°å›¾
char k[4] = {'D', 'L', 'R', 'U'}; //å­—å…¸åº
int dir[4][2] = {{1, 0}, {0, -1}, {0, 1}, { -1, 0}};
int vis[30][50];  //æ ‡è®°ã€‚vis=1: å·²ç»æœè¿‡ï¼Œä¸ç”¨å†æœ

//(2)æ ‡å‡†æ–¹æ³•ï¼š
char pre[31][51];        //   ç”¨äºæŸ¥æ‰¾å‰é©±ç‚¹ã€‚ä¾‹å¦‚pre[x][y] = â€˜Dâ€™ï¼Œè¡¨ç¤ºä¸Šä¸€ä¸ªç‚¹
//å¾€ä¸‹èµ°ä¸€æ­¥åˆ°äº†(x,y)ï¼Œé‚£ä¹ˆä¸Šä¸€ä¸ªç‚¹æ˜¯(x-1,y)
void print_path(int x, int y) {    //æ‰“å°è·¯å¾„ï¼šä»(0,0)åˆ°(29,49)
    if (x == 0 && y == 0)    return; //å›æº¯åˆ°äº†èµ·ç‚¹ï¼Œé€’å½’ç»“æŸï¼Œè¿”å›
    if (pre[x][y] == 'D')  print_path(x - 1, y); //å›æº¯ï¼Œå¾€ä¸Š U
    if (pre[x][y] == 'L')  print_path(x,  y + 1); //å›æº¯ï¼Œå¾€å³ R
    if (pre[x][y] == 'R')  print_path(x,  y - 1);
    if (pre[x][y] == 'U')  print_path(x + 1, y);
    printf("%c", pre[x][y]);                 //æœ€åæ‰“å°çš„æ˜¯ç»ˆç‚¹
}
void bfs() {
    node start; start.x = 0;  start.y = 0;
//(1)ç®€å•æ–¹æ³•ï¼š
    start.path = "";
    vis[0][0] = 1;             //æ ‡è®°èµ·ç‚¹è¢«æœè¿‡
    queue<node>q;
    q.push(start);             //æŠŠç¬¬ä¸€ä¸ªç‚¹æ”¾è¿›é˜Ÿåˆ—ï¼Œå¼€å§‹BFS
    while (!q.empty()) {
        node now = q.front();  //å–å‡ºé˜Ÿé¦–
        q.pop();
        if (now.x == 29 && now.y == 49) { //ç¬¬ä¸€æ¬¡è¾¾åˆ°ç»ˆç‚¹ï¼Œè¿™å°±æ˜¯å­—å…¸åºæœ€å°çš„æœ€çŸ­è·¯å¾„
//(1)ç®€å•æ–¹æ³•ï¼šæ‰“å°å®Œæ•´è·¯å¾„
            cout << now.path << endl;
//(2)æ ‡å‡†æ–¹æ³•ï¼šæ‰“å°å®Œæ•´è·¯å¾„ï¼Œä»ç»ˆç‚¹å›æº¯åˆ°èµ·ç‚¹ï¼Œæ‰“å°å‡ºæ¥æ˜¯ä»èµ·ç‚¹åˆ°ç»ˆç‚¹çš„æ­£åº
            print_path(29, 49);
            return;
        }
        for (int i = 0; i < 4; i++) { //æ‰©æ•£é‚»å±…ç»“ç‚¹
            node next;
            next.x = now.x + dir[i][0];  next.y = now.y + dir[i][1];
            if (next.x < 0 || next.x >= 30 || next.y < 0 || next.y >= 50) //è¶Šç•Œäº†
                continue;
            if (vis[next.x][next.y] == 1 || mp[next.x][next.y] == '1')
                continue;           //vis=1:å·²ç»æœè¿‡;  mp=1:æ˜¯éšœç¢
            vis[next.x][next.y] = 1; //æ ‡è®°è¢«æœè¿‡
//(1)ç®€å•æ–¹æ³•ï¼šè®°å½•å®Œæ•´è·¯å¾„ï¼šå¤åˆ¶ä¸Šä¸€ä¸ªç‚¹çš„è·¯å¾„ï¼ŒåŠ ä¸Šè¿™ä¸€æ­¥
            next.path = now.path + k[i];
//(2)æ ‡å‡†æ–¹æ³•ï¼šè®°å½•ç‚¹(x,y)çš„å‰é©±
            pre[next.x][next.y] = k[i];
            q.push(next);
        }
    }
}
int main() {
    for (int i = 0; i < 30; i++)  cin >> mp[i]; //è¯»é¢˜ç›®ç»™çš„åœ°å›¾æ•°æ®
    bfs();
    return 0;
}
```

### åŒå‘å¹¿æœ

èƒ½ä¸èƒ½ä½¿ç”¨

èƒ½ä¸èƒ½æ”¹å–„å¤æ‚åº¦

åè™½å¦‚æ­¤ä½†ä»ç„¶æ²¡æœ‰æ–¹å‘æ„Ÿ

å¢é•¿è¶Šå¿«ä¼˜åŒ–è¶Šæ˜æ˜¾

çœ‹çœ‹å»é‡æ¡ä»¶ä¹‹åbfsçš„åŠ£åŠ¿è¿˜æ˜ä¸æ˜æ˜¾ï¼Œä¸æ˜æ˜¾å¯ç»§ç»­ä½¿ç”¨ã€‚ç›¸é‡å’Œé˜Ÿç©ºä¸ºç»ˆæ­¢æ¡ä»¶

1.ç½‘æ ¼ç»“æ„

2.æ ‘çŠ¶ç»“æ„ï¼šä»ä¸‹åˆ°ä¸Šå’Œä»ä¸Šåˆ°ä¸‹è¿›è¡Œ

##### *hdu1195*

**å®ç°**

````cpp
#include<iostream>
#include<algorithm>
#include<cstdlib>
#include<sstream>
#include<cstring>
#include<cstdio>
#include<string>
#include<deque>
#include<stack>
#include<cmath>
#include<queue>
#include<set>
#include<map>
using namespace std;
#define INF 0x3f3f3f3f
#define MM(x) memset(x,0,sizeof(x))
#define MMINF(x) memset(x,INF,sizeof(x))
typedef long long LL;
const double PI=acos(-1.0);
const int N=100010;
struct info
{
    char s[5];
    int step;
};
info goal,ori;
int pos[N];
int vis[N];
inline int change(char s[])
{
    int r=0;
    for (int i=0; i<4; ++i)
        r=r*10+s[i]-'0';
    return r;
}
int T_bfs()
{
    queue<info>Qf;
    queue<info>Qb;
    Qf.push(ori);
    Qb.push(goal);
    while ((!Qf.empty())||(!Qb.empty()))
    {
        if(!Qf.empty()&&(Qf.size()>Qb.size()))//è¿™é‡ŒåŠ äº†ä¸ªæ•°é‡åˆ¤æ–­å°±ACäº†
        {
            info now1=Qf.front();
            Qf.pop();
            for (int i=0; i<4; i++)
            {
                info v=now1;
                v.s[i]--;
                if(v.s[i]<49)
                    v.s[i]='9';
                int num=change(v.s);
                if(!pos[num])
                {
                    v.step=now1.step+1;
                    pos[num]=1;
                    vis[num]=v.step;
                    Qf.push(v);
                }
                else if(pos[num]==2)
                    return vis[num]+vis[change(now1.s)];
            }
            for (int i=0; i<4; i++)
            {
                info v=now1;
                v.s[i]++;
                if(v.s[i]>57)
                    v.s[i]='1';
                int num=change(v.s);
                if(!pos[num])
                {
                    v.step=now1.step+1;
                    pos[num]=1;
                    vis[num]=v.step;
                    Qf.push(v);
                }
                else if(pos[num]==2)
                    return vis[num]+vis[change(now1.s)];
            }
            for (int i=0; i<3; i++)
            {
                info v=now1;
                swap(v.s[i],v.s[i+1]);
                int num=change(v.s);
                if(!pos[num])
                {
                    pos[num]=1;
                    v.step=now1.step+1;
                    vis[num]=v.step;
                    Qf.push(v);
                }
                else if(pos[num]==2)
                    return vis[num]+vis[change(now1.s)];
            }
        }
 
        if(!Qb.empty())
        {
            info now2=Qb.front();
            Qb.pop();
            for (int i=0; i<4; i++)
            {
                info v=now2;
                v.s[i]--;
                if(v.s[i]<49)
                    v.s[i]='9';
                int num=change(v.s);
                if(!pos[num])
                {
                    v.step=now2.step+1;
                    pos[num]=2;
                    vis[num]=v.step;
                    Qb.push(v);
                }
                else if(pos[num]==1)
                    return vis[num]+vis[change(now2.s)];
            }
            for (int i=0; i<4; i++)
            {
                info v=now2;
                v.s[i]++;
                if(v.s[i]>57)
                    v.s[i]='1';
                int num=change(v.s);
                if(!pos[num])
                {
                    v.step=now2.step+1;
                    pos[num]=2;
                    vis[num]=v.step;
                    Qb.push(v);
                }
                else if(pos[num]==1)
                    return vis[num]+vis[change(now2.s)];
            }
            for (int i=0; i<3; i++)
            {
                info v=now2;
                swap(v.s[i],v.s[i+1]);
                int num=change(v.s);
                if(!pos[num])
                {
                    v.step=now2.step+1;
                    pos[num]=2;
                    vis[num]=v.step;
                    Qb.push(v);
                }
                else if(pos[num]==1)
                    return vis[num]+vis[change(now2.s)];
            }
        }
    }
}
int main(void)//ä¸æ˜¯ç‰¹åˆ«å¥½çš„æ–¹æ³•
{
    int tcase;
    scanf("%d",&tcase);
    while (tcase--)
    {
        MM(pos);
        MM(vis);
        scanf("%s %s",ori.s,goal.s);
        ori.step=0;
        goal.step=0;
        pos[change(ori.s)]=1;
        pos[change(goal.s)]=2;
        vis[change(ori.s)]=0;
        vis[change(goal.s)]=0;
        !strcmp(ori.s,goal.s)?puts("0"):printf("%d\n",T_bfs()+1);
    }
    return 0;
}
````

##### *hdu1401*

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#include <queue>
#include <map>
#include <cstring>
using namespace std;
int dir[4][2] = {{0,1},{1,0},{-1,0},{0,-1}};//å››ä¸ªè½¬ç§» 
map<int , int > V,V1; //å¯¹åº”æ˜¯å¦æœ‰é‚£ä¸ªçŠ¶æ€ 
struct k{
		int x,y;
		bool operator < ( const k& b) const{
			if ( x == b.x ) return y < b.y;
				return x < b.x;
		}//æ’åºç”¨çš„ 
};
struct stu{
	k a[4];
	int vis;//è®°å½•ç¬¬å‡ æ­¥ 
}s[2];
int BFS(stu s,int kk){
	queue <stu> q;
	stu be,nex;
	sort(s.a,s.a+4); 
	int Z  = 0;
		for (int i = 0; i < 4; i++)
		{
			Z+= s.a[i].x << (6*i);
				Z+= s.a[i].y << (6*i+3);
		}//å¯¹åº”æ¯ä¸ªçŠ¶æ€ æ€»å…±å…«ä¸ªç‚¹æŠŠå…¶ä»å¤§åˆ°å°æ’åºåå³å¯åŒ–ä¸ºä¸€ä¸ª24ä½çš„äºŒè¿›åˆ¶æ¥è¡¨ç¤º 
	if(!kk){		
		V[Z] = 1;
	} 
	else{
		V1[Z] = 1;
		if(V[Z]) return 1;//äºŒæ¬¡è¿›å…¥çš„æ—¶å€™ç›´æ¥åˆ¤æ–­ä¸€ä¸‹æœ‰æœ¨æœ‰èµ°è¿‡å³å¯ 
	}
 	be = s; 
	q.push(be);
	while(!q.empty())
	{
		be = q.front(); q.pop();
		if( be.vis == 4 ) break;
		for (int i = 0; i < 4; i++)//å“ªä¸ª 
		{
			int x = be.a[i].x,y = be.a[i].y;
			for (int j = 0; j < 4; j++)//ä½ç§» 
			{
				int newx = x+dir[j][0],newy = y+dir[j][1];
				for (int z = 0; z < 4; z++)
				{
					if(z != i && newx == be.a[z].x && newy == be.a[z].y)
					{
						newx += dir[j][0]; newy += dir[j][1];
					}
				}//å†ç»§ç»­ç¿» 
				if (newx >= 1 && newy <= 8 && newy >= 1 && newy <= 8) 
				{
					nex = be;
					nex.a[i].x = newx; nex.a[i].y = newy;
					sort(nex.a,nex.a+4); nex.vis = be.vis + 1;
					int Z  = 0;
					for (int i = 0; i < 4; i++) // è½¬ä¸º24ä½äºŒè¿›åˆ¶ 
					{
							Z+= nex.a[i].x << (6*i);
								Z+= nex.a[i].y << (6*i+3);
					}
					if(!kk)
					{
						if(! V.count(Z)){
							V[Z] = 1;
							q.push(nex);
						}
					}
					else
					{
						if(! V1.count(Z)){
							V1[Z] = 1;
							if(V[Z]) return 1; 
							q.push(nex);
						}
					}//åŒç† 
					
				}
				
			}
		}
	}
	return 0;
}
int main()
{
	while(~scanf("%d%d",&s[0].a[0].x,&s[0].a[0].y))
	{	 
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < 4; j++)
			{
				if(!i && !j) continue;
				scanf("%d%d",&s[i].a[j].x,&s[i].a[j].y);
			}
		}
		V.clear();
		V1.clear();
		s[0].vis = 0; s[1].vis = 0;//åˆå§‹åŒ– 
		BFS(s[0],0); 
		if(BFS(s[1],1)) printf("YES\n");
		else printf("NO\n");
	}
	return 0;
 } 
```
##### *p1023*

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <unordered_map>
using namespace std;
const int N = 6;
int n;
string a[N], b[N];
int extend(queue <string>&q, unordered_map <string, int>&da, unordered_map <string, int>&db, string a[], string b[]){
     string t = q.front();
  q.pop();
   for (int i = 0; i < t.size(); i ++) 
      for (int j = 0; j < n; j ++)
    if (t.substr(i, a[j].size()) == a[j]){
     string state = t.substr(0, i) +b[j] + t.substr(i + a[j].size());
     if(db.count(state))   return da[t] + 1 + db[state];
     if(da.count(state))   continue;
     da[state] = da[t] + 1;
     q.push(state);
    } 
  return 11;
}
int bfs(string A,string B){
 queue <string> qa,qb;
 unordered_map <string, int> da,db;
 qa.push(A),      da[A] = 0;
 qb.push(B),      db[B] = 0;
  while(qa.size() && qb.size()){
  int t;
  if (qa.size() < qb.size())    t = extend(qa, da, db, a, b);
  else    t = extend(qb, db, da, b, a);
  if (t <= 10)    return  t;
 }
 return 11;
}
int main(){
 string A, B;
 cin >> A >> B;
 while (cin >> a[n] >> b[n])    n ++;
 int step = bfs(A, B);
 if (step > 10)     puts("NO ANSWER!");
 else               printf("%d\n", step);
 return 0;
}
```

### bfsä¸ä¼˜å…ˆé˜Ÿåˆ—

ç®€å•ç†è§£ä¸ºå›¾è®ºä¸Šçš„Dijkstra

ä¼˜å…ˆé˜Ÿåˆ—ä¸­çš„å…ƒç´ ä½ç½®æ˜¯æ ¹æ®ä¼˜å…ˆçº§æ¥æ’çš„

ç¨€ç–å›¾é‚»æ¥è¡¨é“¾å¼å‘å‰æ˜Ÿï¼šï¼ˆn+mï¼‰logn

ç¨ å¯†å›¾è¿æ¥çŸ©é˜µï¼ˆè¾¹å¤§äºç‚¹ï¼‰ï¼šn*nä¸å¦‚ç›´æ¥æš´åŠ›
##### æœ€çŸ­è·¯å¾„dijkstraæ¨¡æ¿

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long INF = 0x3f3f3f3f3f3f3f3fLL;      //è¿™æ ·å®šä¹‰çš„å¥½å¤„æ˜¯: INF <= INF+x
const int N = 3e5+2;
struct edge{
int from, to;   //è¾¹ï¼šèµ·ç‚¹ï¼Œç»ˆç‚¹ï¼Œæƒå€¼ã€‚èµ·ç‚¹fromå¹¶æ²¡æœ‰ç”¨åˆ°ï¼Œe[i]çš„iå°±æ˜¯from
long long w;    //è¾¹ï¼šæƒå€¼
    edge(int a, int b,long long c){from=a; to=b; w=c;}
};
vector<edge>e[N];   		          //å­˜å‚¨å›¾
struct node{
    int id; long long n_dis;          //idï¼šç»“ç‚¹ï¼›n_disï¼šè¿™ä¸ªç»“ç‚¹åˆ°èµ·ç‚¹çš„è·ç¦»
    node(int b,long long c){id=b; n_dis=c;}
    bool operator < (const node & a) const
    { return n_dis > a.n_dis;}
};
int n,m;
int pre[N];                          //è®°å½•å‰é©±ç»“ç‚¹
void print_path(int s, int t) {       //æ‰“å°ä»såˆ°tçš„æœ€çŸ­è·¯
    if(s==t){ printf("%d ", s); return; }     //æ‰“å°èµ·ç‚¹
    print_path(s, pre[t]);            //å…ˆæ‰“å°å‰ä¸€ä¸ªç‚¹
    printf("%d ", t);                 //åæ‰“å°å½“å‰ç‚¹ã€‚æœ€åæ‰“å°çš„æ˜¯ç»ˆç‚¹t
}
long long  dis[N];                    //è®°å½•æ‰€æœ‰ç»“ç‚¹åˆ°èµ·ç‚¹çš„è·ç¦»
bool done[N];                         //done[i]=trueè¡¨ç¤ºåˆ°ç»“ç‚¹içš„æœ€çŸ­è·¯å¾„å·²ç»æ‰¾åˆ°
void dijkstra(){
    int s = 1;                        //èµ·ç‚¹s = 1
    for (int i=1;i<=n;i++) {dis[i]=INF; done[i]=false; }    //åˆå§‹åŒ–
    dis[s]=0;                         //èµ·ç‚¹åˆ°è‡ªå·±çš„è·ç¦»æ˜¯0
    priority_queue <node> Q;          //ä¼˜å…ˆé˜Ÿåˆ—ï¼Œå­˜ç»“ç‚¹ä¿¡æ¯
    Q.push(node(s, dis[s]));          //èµ·ç‚¹è¿›é˜Ÿåˆ—
    while (!Q.empty())   {
        node u = Q.top();             //popå‡ºè·èµ·ç‚¹sè·ç¦»æœ€å°çš„ç»“ç‚¹u
        Q.pop();
        if(done[u.id]) continue;      //ä¸¢å¼ƒå·²ç»æ‰¾åˆ°æœ€çŸ­è·¯å¾„çš„ç»“ç‚¹ã€‚å³é›†åˆAä¸­çš„ç»“ç‚¹            
        done[u.id]= true;
        for (int i=0; i<e[u.id].size(); i++) {  //æ£€æŸ¥ç»“ç‚¹uçš„æ‰€æœ‰é‚»å±…
            edge y = e[u.id][i];       //u.idçš„ç¬¬iä¸ªé‚»å±…æ˜¯y.to
            if(done[y.to]) continue;   //ä¸¢å¼ƒå·²ç»æ‰¾åˆ°æœ€çŸ­è·¯å¾„çš„é‚»å±…ç»“ç‚¹                
            if (dis[y.to] > y.w + u.n_dis) {
                dis[y.to] = y.w + u.n_dis;
                Q.push(node(y.to, dis[y.to]));    //æ‰©å±•æ–°é‚»å±…ï¼Œæ”¾åˆ°ä¼˜å…ˆé˜Ÿåˆ—ä¸­
                pre[y.to]=u.id;        //å¦‚æœæœ‰éœ€è¦ï¼Œè®°å½•è·¯å¾„
            }
        }
    }
    // print_path(s,n);                //å¦‚æœæœ‰éœ€è¦ï¼Œæ‰“å°è·¯å¾„: èµ·ç‚¹1ï¼Œç»ˆç‚¹n
}
int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)   e[i].clear();
    while (m--) {
        int u,v,w;   scanf("%d%d%lld",&u,&v,&w);
        e[u].push_back(edge(u,v,w));
     // e[v].push_back(edge(v,u,w));     //æœ¬é¢˜æ˜¯å•å‘è¾¹
    }
    dijkstra();
    for(int i=1;i<=n;i++){
        if(dis[i]>=INF)  cout<<"-1 ";
        else   printf("%lld ", dis[i]);
    }
}

```

### å›¾ä¸­dijkstraçš„åº”ç”¨

[](https://codeforces.com/contest/1749/problem/E)



> E.ä»™äººæŒå¢™
> æ¯æ¬¡æµ‹è¯•çš„æ—¶é—´é™åˆ¶2ç§’
> æ¯æ¬¡æµ‹è¯•çš„å†…å­˜é™åˆ¶256å…†å­—èŠ‚
> è¾“å…¥æ ‡å‡†è¾“å…¥
> è¾“å‡ºæ ‡å‡†è¾“å‡º
> Monocarpæ­£åœ¨ç©Minecraftï¼Œä»–æƒ³å»ºé€ ä¸€å µä»™äººæŒå¢™ã€‚ä»–æƒ³æŠŠå®ƒå»ºåœ¨ä¸€å—å¤§å°ä¸ºnÃ—må•å…ƒçš„æ²™åœ°ä¸Šã€‚æœ€åˆï¼Œåœºåœ°çš„ä¸€äº›å•å…ƒé‡Œæœ‰ä»™äººæŒã€‚è¯·æ³¨æ„ï¼Œåœ¨Minecraftä¸­ï¼Œä»™äººæŒä¸èƒ½ç”Ÿé•¿åœ¨ä¾§é¢ç›¸é‚»çš„å•å…ƒæ ¼ä¸Š--è€Œåˆå§‹åœºåœ°ç¬¦åˆè¿™ä¸€é™åˆ¶ã€‚Monocarpå¯ä»¥ç§æ¤æ–°çš„ä»™äººæŒï¼ˆå®ƒä»¬ä¹Ÿå¿…é¡»æ»¡è¶³å‰è¿°æ¡ä»¶ï¼‰ã€‚ä»–ä¸èƒ½ç æ‰ä»»ä½•å·²ç»ç”Ÿé•¿åœ¨ç”°åœ°ä¸Šçš„ä»™äººæŒ--ä»–æ²¡æœ‰æ–§å¤´ï¼Œè€Œä¸”ä»™äººæŒå¯¹ä»–çš„æ‰‹æ¥è¯´å¤ªæ‰æ‰‹äº†ã€‚
>
> è«è¯ºå¡æ™®è®¤ä¸ºï¼Œå¦‚æœä»ç”°åœ°çš„æœ€ä¸Šé¢ä¸€æ’åˆ°æœ€ä¸‹é¢ä¸€æ’æ²¡æœ‰è·¯å¾„ï¼Œé‚£ä¹ˆè¿™å µå¢™å°±æ˜¯å®Œæ•´çš„ï¼Œè¿™æ ·ã€‚
>
> è·¯å¾„ä¸Šçš„æ¯ä¸¤ä¸ªè¿ç»­å•å…ƒéƒ½æ˜¯ç›¸é‚»çš„ã€‚
> å±äºè¯¥è·¯å¾„çš„å•å…ƒæ ¼ä¸­æ²¡æœ‰ä»™äººæŒã€‚
> ä½ çš„ä»»åŠ¡æ˜¯ç§æ¤æœ€å°æ•°é‡çš„ä»™äººæŒæ¥å»ºé€ ä¸€å µå¢™ï¼ˆæˆ–æŠ¥å‘Šè¯´è¿™æ˜¯ä¸å¯èƒ½çš„ï¼‰ã€‚
>
> è¾“å…¥
> ç¬¬ä¸€è¡ŒåŒ…å«ä¸€ä¸ªæ•´æ•°t--æµ‹è¯•æ¡ˆä¾‹çš„æ•°é‡ã€‚
>
> æ¯ä¸ªæµ‹è¯•æ¡ˆä¾‹çš„ç¬¬ä¸€è¡ŒåŒ…å«ä¸¤ä¸ªæ•´æ•°nå’Œmï¼ˆ2â‰¤n,mâ‰¤2â‹…1052â‰¤n,mâ‰¤2â‹…105ï¼›nÃ—mâ‰¤4â‹…105nÃ—mâ‰¤4â‹…105ï¼‰--åˆ†åˆ«ä¸ºè¡Œå’Œåˆ—çš„æ•°é‡ã€‚
>
> ç„¶ånè¡Œï¼Œç¬¬iè¡ŒåŒ…å«ä¸€ä¸ªé•¿åº¦ä¸ºmçš„å­—ç¬¦ä¸²siï¼Œå…¶ä¸­si,jä¸º'#'ï¼Œå¦‚æœåœ¨ç¬¬iè¡Œå’Œç¬¬jåˆ—çš„äº¤æ±‡å¤„é•¿æœ‰ä»™äººæŒã€‚å¦åˆ™ï¼Œsi,jsi,jä¸º'.'ã€‚
>
> æ‰€æœ‰æµ‹è¯•æ¡ˆä¾‹çš„nÃ—mä¹‹å’Œä¸è¶…è¿‡4â‹…1054â‹…105ã€‚
>
> è¾“å‡º
> å¯¹äºæ¯ä¸ªæµ‹è¯•æ¡ˆä¾‹ï¼Œå¦‚æœä¸å¯èƒ½åœ¨ä¸è¿åè§„åˆ™çš„æƒ…å†µä¸‹å»ºé€ ä»™äººæŒå¢™ï¼Œåˆ™åœ¨ç¬¬ä¸€è¡Œæ‰“å°NOã€‚å¦åˆ™ï¼Œåœ¨ç¬¬ä¸€è¡Œæ‰“å° "æ˜¯"ï¼Œç„¶åæ‰“å°nè¡Œï¼Œæ¯è¡Œæœ‰mmä¸ªå­—ç¬¦--å­—æ®µæœ¬èº«ï¼Œå…¶ä¸­ç¬¬iiè¡Œçš„ç¬¬jä¸ªå­—ç¬¦ç­‰äº "#"ï¼Œå¦‚æœåœ¨ç¬¬iiè¡Œå’Œç¬¬jåˆ—çš„äº¤å‰ç‚¹ä¸Šæœ‰ä¸€ä¸ªä»™äººæŒï¼Œå¦åˆ™å°±æ˜¯"ã€‚å¦‚æœæœ‰å¤šä¸ªæœ€ä½³ç­”æ¡ˆï¼Œåˆ™æ‰“å°å…¶ä¸­ä»»ä½•ä¸€ä¸ªã€‚

```java

import java.util.Scanner;
import java.util.PriorityQueue;

public class Main{

	static final int N = (int)4e5 + 9;
	static boolean[][] field;
	static boolean[] fixed = new boolean[N];
	static int[] pre = new int[N], head = new int[N], dist = new int[N];
	static int[][] e = new int[N << 2][3];
	static int tot, des;
	static final int inf = 0x3f3f3f3f;

	public static void main(String[] args){
		int i, j, m, n, tt;
		int u, v, w;
		String str;
		Scanner in = new Scanner(System.in);
		StringBuilder ans = new StringBuilder();
		
		tt = in.nextInt();
		while(tt -- > 0){
			n = in.nextInt();
			m = in.nextInt();
			field = new boolean[n + 9][m + 9];
			for(i = n * m; i > 0; -- i) dist[i] = inf;
			for(i = 1; i <= n; ++ i){
				str = in.next();
				for(j = 0; j < m; ++ j)
					field[i][j + 1] = str.charAt(j) == '#';
			}
			for(i = 1, tot = 0; i <= n; ++ i){
				for(j = 2; j <= m; ++ j){
					if(field[i][j - 1] || field[i][j + 1]) continue;
					if(field[i - 1][j] || field[i + 1][j]) continue;
					v = (i - 1) * m + j; w = 1;
					if(field[i][j]) w = 0;
					if(i > 1){
						u = (i - 1 - 1) * m + j - 1;
						ae(u, v, w);
						if(j < m){
							u = (i - 1 - 1) * m + j + 1;
							ae(u, v, w);
						}
					}
					if(i < n){
						u = (i + 1 - 1) * m + j - 1;
						ae(u, v, w);
						if(j < m){
							u = (i + 1 - 1) * m + j + 1;
							ae(u, v, w);
						}
					}
				}
			}
			for(i = v = 1, u = 0; i <= n; ++ i, v += m){
				if(field[i][2]) continue;
				if(field[i - 1][1]|| field[i + 1][1]) continue;
				if(field[i][1]) w = 0;
				else w = 1;
				ae(u, v, w);
			}
			dijkstra(0, m);
			if(des > 0){
				ans.append("YES\n");
				while(des > 0){
					i = (des + m - 1) / m; j = des % m;
					if(j == 0) j = m;
					field[i][j] = true; des = pre[des];
				}
				for(i = 1; i <= n; ++ i){
					for(j = 1; j <= m; ++ j)
						if(field[i][j]) ans.append('#');
						else ans.append('.');
					ans.append('\n');
				}
			}
			else ans.append("NO\n");
			
			for(i = n * m; i >= 0; -- i){
				head[i] = 0; fixed[i] = false;
			}
		}
		System.out.printf("%s", ans);
	}
	
	static void ae(int u, int v, int w){
		e[++ tot][0] = v; e[tot][1] = head[u];
		e[tot][2] = w; head[u] = tot;
	}
	
	static void dijkstra(int s, int m){
		int i, u, v, w;
		PriorityQueue<node> pq = new PriorityQueue<>();
		pq.add(new node(s, 0));
		while(!pq.isEmpty()){
			u = pq.poll().ind;
			if(u > 0 && u % m == 0){
				des = u; break;
			}
			for(i = head[u]; i > 0; i = e[i][1]){
				v = e[i][0]; w = e[i][2];
				if(dist[v] > dist[u] + w){
					dist[v] = dist[u] + w; pre[v] = u;
					pq.add(new node(v, dist[v]));
				}
			}
		}
	}
}

class node implements Comparable<node>{
	int ind, dis;
	node(int a, int b){
		ind = a; dis = b;
	}	
    //public int compare(node o1, node o2) {
    //        return o2.dis - o1.dis; //å¤§çš„åœ¨å‰
    //   }
	public int compareTo(node z){
		if(dis < z.dis) return -1;
		else if(dis > z.dis) return 1;
		return 0;
	}
}
```



### bfsä¸åŒç«¯é˜Ÿåˆ—

è§£å†³å›¾çš„è¾¹æƒä¸º1or0çš„ç‰¹æ®Šå›¾æƒ…å†µ
##### switch the lamp on
```cpp
#include<bits/stdc++.h>
using namespace std;
const int dir[4][2] = {{-1,-1},{-1,1},{1,-1},{1,1}}; //4ä¸ªæ–¹å‘çš„ä½ç§»
const int ab[4] = {2,1,1,2};                         //4ä¸ªå…ƒä»¶æœŸæœ›çš„æ–¹å‘
const int cd[4][2] = {{-1,-1},{-1,0},{0,-1},{0,0}};  //4ä¸ªå…ƒä»¶ç¼–å·çš„ä½ç§»
int graph[505][505],dis[505][505];                   //disè®°å½•ç»“ç‚¹åˆ°èµ·ç‚¹sçš„æœ€çŸ­è·¯
struct P{ int x,y,dis; }u;
int read_ch(){
    char c;
    while((c = getchar())!='/' && c != '\\') ;   //å­—ç¬¦ä¸æ˜¯'/'å’Œ'\'
    return c=='/' ? 1 : 2;
}
int main(){
    int n, m; cin >>n >>m;
    memset(dis,0x3f,sizeof(dis));
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)   graph[i][j] = read_ch();
    deque <P> dq;
    dq.push_back((P){1,1,0}); 
    dis[1][1] = 0;
    while(!dq.empty()){
        u = dq.front(), dq.pop_front();   //front()è¯»é˜Ÿå¤´,pop_front()å¼¹å‡ºé˜Ÿå¤´
        int nx,ny;
        for(int i=0;i<=3;++i) {           //4ä¸ªæ–¹å‘
            nx = u.x+dir[i][0];  ny = u.y+dir[i][1];
            int d = 0;                    //è¾¹æƒ
            d = graph[u.x+cd[i][0]][u.y+cd[i][1]]!=ab[i];   //è‹¥æ–¹å‘ä¸ç›¸ç­‰,åˆ™d=1
            if(nx && ny && nx<n+2 && ny<m+2 && dis[nx][ny]>dis[u.x][u.y]+d){
              //    å¦‚æœä¸€ä¸ªç»“ç‚¹å†æ¬¡è¿›é˜Ÿï¼Œé‚£ä¹ˆè·ç¦»åº”è¯¥æ›´å°ã€‚å®é™…ä¸Šï¼Œ
                //ç”±äºå†æ¬¡è¿›é˜Ÿæ—¶ï¼Œè·ç¦»è‚¯å®šæ›´å¤§ï¼Œæ‰€ä»¥è¿™é‡Œçš„ä½œç”¨æ˜¯é˜»æ­¢å†æ¬¡å…¥é˜Ÿ
                  dis[nx][ny] = dis[u.x][u.y]+d; 
                  if(d==0)  dq.push_front((P){nx, ny, dis[nx][ny]});  //è¾¹æƒ=0ï¼Œæ’åˆ°é˜Ÿå¤´                                          
                  else dq.push_back ((P){nx, ny, dis[nx][ny]});       //è¾¹æƒ=1ï¼Œæ’åˆ°é˜Ÿå°¾
                  if(nx==n+1 && ny==m+1) break;     //åˆ°ç»ˆç‚¹é€€å‡ºã€‚ä¸é€€ä¹Ÿè¡Œï¼Œé˜Ÿåˆ—ç©ºè‡ªåŠ¨é€€                    
            }
        }
    }
    if(dis[n+1][m+1] != 0x3f3f3f3f)  cout << dis[n+1][m+1];
    else   cout <<"NO SOLUTION";         //å¯èƒ½æ— è§£ï¼Œå³såˆ°tä¸é€š
    return 0;
}

```

### A*
#### è´ªå¿ƒæœ€ä¼˜å’Œdijkstra
è´ªå¿ƒå‡ºè¯¥ç‚¹è·ç¦»åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·ç¦»
dijkstraæ±‚å‡ºåˆ°è¯¥ç‚¹æœ€çŸ­çš„è·¯å¾„
f=g+h
å¯¹içš„è¯„ä¼°=èµ·ç‚¹åˆ°è¯¥ç‚¹çš„ä»£ä»·+è¯¥ç‚¹åˆ°ç»ˆç‚¹çš„ä»£ä»·
g håº”å½“æ˜¯åŒæ ·çš„è®¡ç®—æ–¹æ³•  håº”è¯¥ä¼˜äºæ‰€æœ‰å®é™…å­˜åœ¨çš„è·¯å¾„
![](æœç´¢/æœç´¢0.png)
##### ç¬¬kè·¯å¾„æœ€çŸ­
```cpp
// poj 2449ä»£ç 
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1005, M = 100005;
struct edge{          //è®°å½•è¾¹
int to, w;
//vector edge[i]:èµ·ç‚¹æ˜¯i;å®ƒæœ‰å¾ˆå¤šè¾¹,å…¶ä¸­ä¸€ä¸ªè¾¹çš„toæ˜¯è¾¹çš„ç»ˆç‚¹,wæ˜¯è¾¹é•¿
    edge(int a,int b){ to = a, w = b;} //èµ‹å€¼
};
vector <edge>G[M], G2[M];  //G:åŸå›¾; G2:åå›¾
struct node {      //ç”¨äºdijkstraã€‚è®°å½•ç‚¹ï¼Œä»¥åŠç‚¹åˆ°èµ·ç‚¹çš„è·¯å¾„
    int id, dis;   //id:ç‚¹ï¼›disï¼šç‚¹idåˆ°èµ·ç‚¹çš„è·¯å¾„é•¿åº¦
    node(int a, int b){ id = a, dis = b;} //èµ‹å€¼
    bool operator < (const node &u) const { return dis > u.dis; }
};
int  dist[N];   //dist[i]: ä»såˆ°ç‚¹içš„æœ€çŸ­è·¯é•¿åº¦
bool done[N];   //done[i]=ture: è¡¨ç¤ºåˆ°içš„æœ€çŸ­è·¯å·²ç»æ‰¾åˆ°
void dijkstra(int s) {    //æ ‡å‡†çš„dijkstra: æ±‚såˆ°å…¶ä»–æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯
    for(int i =0;i<N;i++) {dist[i]=INF; done[i]=false;}  //åˆå§‹åŒ–
    dist[s] = 0;          //èµ·ç‚¹såˆ°è‡ªå·±çš„è·ç¦»æ˜¯0
    priority_queue<node> q;
    q.push(node(s, dist[s]));    //ä»èµ·ç‚¹å¼€å§‹å¤„ç†é˜Ÿåˆ—
    while (!q.empty()) {
        node u = q.top();        //popå‡ºè·èµ·ç‚¹sæœ€è¿‘çš„ç‚¹u
        q.pop();
        if (done[u.id])  continue; //ä¸¢å¼ƒå·²ç»æ‰¾åˆ°æœ€çŸ­è·¯çš„ç‚¹            
        done[u.id] = true;       //æ ‡è®°ï¼šç‚¹uåˆ°sçš„æœ€çŸ­è·¯å·²ç»æ‰¾åˆ°
        for (int i = 0; i< G2[u.id].size(); i++) {  //æ£€æŸ¥ç‚¹uçš„æ‰€æœ‰é‚»å±…
            edge y = G2[u.id][i];
            if (done[y.to])   continue; //ä¸¢å¼ƒå·²ç»æ‰¾åˆ°æœ€çŸ­è·¯çš„é‚»å±…                
            if (dist[y.to] > u.dis + y.w) {
                dist[y.to] = u.dis + y.w;
                q.push(node(y.to, dist[y.to]));  //æ‰©å±•æ–°çš„é‚»å±…ï¼Œæ”¾è¿›ä¼˜å…ˆé˜Ÿåˆ—
            }
        }
    }
}
struct point {      //ç”¨äº astar
    int v, g, h;    //è¯„ä¼°å‡½æ•° f = g + h, gæ˜¯ä»såˆ°içš„é•¿åº¦ï¼Œhæ˜¯ä»iåˆ°tçš„é•¿åº¦
    point(int a, int b, int c) { v=a, g=b, h=c; }
    bool operator < (const point & b) const { return g + h > b.g + b.h;}
};
int times[N];     //times[i]: ç‚¹iè¢«è®¿é—®çš„æ¬¡æ•°
int astar(int s, int t, int k){
    memset(times, 0, sizeof(times));
    priority_queue<point> q;
    q.push(point(s, 0, 0));
    while (!q.empty()) {
        point p = q.top();   //ä»ä¼˜å…ˆé˜Ÿåˆ—ä¸­å¼¹å‡ºf = g + hæœ€å°çš„
        q.pop();
        times[p.v]++;
        if (times[p.v] == k && p.v == t)  //ä»é˜Ÿåˆ—ä¸­ç¬¬kæ¬¡å¼¹å‡ºtï¼Œå°±æ˜¯ç­”æ¡ˆ
            return p.g + p.h;
        for (int i = 0; i< G[p.v].size(); i++) {
            edge y = G[p.v][i];
            q.push(point(y.to, p.g + y.w, dist[y.to]));
        }
    }
    return -1;
}
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    while (m--) {
        int a, b, w;             //è¯»è¾¹ï¼šèµ·ç‚¹ã€ç»ˆç‚¹ã€è¾¹é•¿
        scanf("%d%d%d", &a, &b, &w);  //æœ¬é¢˜æ˜¯æœ‰å‘å›¾
         G[a].push_back(edge(b,w));  //åŸå›¾
        G2[b].push_back(edge(a,w));  //åå›¾
    }
    int s, t, k;
    scanf("%d%d%d", &s, &t, &k);
    if (s == t)  k++;         //ä¸€ä¸ªå°é™·é˜±
    dijkstra(t);              //åœ¨åå›¾G2ä¸Šï¼Œæ±‚ç»ˆç‚¹tåˆ°å…¶ä»–ç‚¹çš„æœ€çŸ­è·¯
    printf("%d\n", astar(s, t, k));  //åœ¨åŸå›¾Gä¸Šï¼Œæ±‚ç¬¬kçŸ­è·¯
    return 0;
}

```





### IDA* IDDFS



## åº”ç”¨

### æœ‰æ•ˆåŸºå› å˜æ¢ï¼ˆbfs åŒå‘bfs  A* å›¾è®ºï¼‰

åŸºå› åºåˆ—å¯ä»¥è¡¨ç¤ºä¸ºä¸€æ¡ç”± 8 ä¸ªå­—ç¬¦ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œå…¶ä¸­æ¯ä¸ªå­—ç¬¦éƒ½æ˜¯ `'A'`ã€`'C'`ã€`'G'` å’Œ `'T'` ä¹‹ä¸€ã€‚

å‡è®¾æˆ‘ä»¬éœ€è¦è°ƒæŸ¥ä»åŸºå› åºåˆ— `start` å˜ä¸º `end` æ‰€å‘ç”Ÿçš„åŸºå› å˜åŒ–ã€‚ä¸€æ¬¡åŸºå› å˜åŒ–å°±æ„å‘³ç€è¿™ä¸ªåŸºå› åºåˆ—ä¸­çš„ä¸€ä¸ªå­—ç¬¦å‘ç”Ÿäº†å˜åŒ–ã€‚

- ä¾‹å¦‚ï¼Œ`"AACCGGTT" --> "AACCGGTA"` å°±æ˜¯ä¸€æ¬¡åŸºå› å˜åŒ–ã€‚

å¦æœ‰ä¸€ä¸ªåŸºå› åº“ `bank` è®°å½•äº†æ‰€æœ‰æœ‰æ•ˆçš„åŸºå› å˜åŒ–ï¼Œåªæœ‰åŸºå› åº“ä¸­çš„åŸºå› æ‰æ˜¯æœ‰æ•ˆçš„åŸºå› åºåˆ—ã€‚ï¼ˆå˜åŒ–åçš„åŸºå› å¿…é¡»ä½äºåŸºå› åº“ `bank` ä¸­ï¼‰

ç»™ä½ ä¸¤ä¸ªåŸºå› åºåˆ— `start` å’Œ `end` ï¼Œä»¥åŠä¸€ä¸ªåŸºå› åº“ `bank` ï¼Œè¯·ä½ æ‰¾å‡ºå¹¶è¿”å›èƒ½å¤Ÿä½¿ `start` å˜åŒ–ä¸º `end` æ‰€éœ€çš„æœ€å°‘å˜åŒ–æ¬¡æ•°ã€‚å¦‚æœæ— æ³•å®Œæˆæ­¤åŸºå› å˜åŒ–ï¼Œè¿”å› `-1` ã€‚

æ³¨æ„ï¼šèµ·å§‹åŸºå› åºåˆ— `start` é»˜è®¤æ˜¯æœ‰æ•ˆçš„ï¼Œä½†æ˜¯å®ƒå¹¶ä¸ä¸€å®šä¼šå‡ºç°åœ¨åŸºå› åº“ä¸­ã€‚

 

**ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼šstart = "AACCGGTT", end = "AACCGGTA", bank = ["AACCGGTA"]
è¾“å‡ºï¼š1
```



#### BFS

ä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬ä»¤ S=startã€ T=endï¼Œå°†æ¯ä¸ªåŸºå› åºåˆ—è§†ä¸ºã€ŒçŠ¶æ€ã€ã€‚

å®¹æ˜“æƒ³åˆ°ä½¿ç”¨ `BFS` è¿›è¡Œæ±‚è§£ï¼Œå¹¶ä½¿ç”¨ã€Œå“ˆå¸Œè¡¨ã€è®°å½•åˆ°è¾¾æŸä¸ªçŠ¶æ€æ‰€æ¶ˆè€—çš„æ­¥æ•°ï¼ˆåŒæ—¶ä¸ºäº†å¿«é€Ÿåˆ¤æ–­æŸä¸ªçŠ¶æ€æ˜¯å¦åˆæ³•ï¼Œæˆ‘ä»¬ä½¿ç”¨ `Set` ç»“æ„å¯¹ bank[i] è¿›è¡Œè½¬å­˜ï¼‰ã€‚

èµ·å§‹å°† `S` åŠ å…¥é˜Ÿåˆ—ï¼Œå¹¶æ›´æ–°åˆ°è¾¾ `S` æ‰€ä½¿ç”¨çš„æ­¥æ•°ä¸º 0ï¼Œç„¶åè¿›è¡Œå¸¸è§„çš„ `BFS` è¿‡ç¨‹ï¼šæ¯æ¬¡å–å‡ºé˜Ÿå¤´å…ƒç´ ï¼Œå°è¯•æ›¿æ¢å½“å‰çŠ¶æ€çš„æŸä¸€ä½ï¼Œæ¥å¾—åˆ°æ–°çš„çŠ¶æ€ï¼ˆé™å®šæ–°çŠ¶æ€å¿…é¡»åˆæ³•ï¼Œå³å¿…é¡»å‡ºç°åœ¨ `Set` ä¸­ï¼‰ï¼Œå¦‚æœæ–°çŠ¶æ€åˆæ³•å¹¶ä¸”æ²¡æœ‰åœ¨è®°å½•æ­¥æ•°çš„å“ˆå¸Œè¡¨ä¸­å‡ºç°è¿‡ï¼Œåˆ™å°†æ–°çŠ¶æ€å…¥é˜Ÿå¹¶æ›´æ–°å¾—åˆ°æ–°çŠ¶æ€æ‰€ç”¨æ­¥æ•°ï¼Œå¦åˆ™ä¸¢å¼ƒæ–°çŠ¶æ€ã€‚

é‡å¤ä¸Šè¿°è¿‡ç¨‹ç›´åˆ°æ‰¾åˆ° `T`ï¼ˆè¿”å›å…·ä½“æ­¥æ•°ï¼‰ æˆ–è€…é˜Ÿåˆ—ä¸ºç©ºï¼ˆè¿”å› âˆ’1ï¼‰ã€‚

ä»£ç ï¼š

Java

```java
class Solution {
    static Deque<String>d;
    static char chs[]=new char[]{'A','C','G','T'};//æ ¹æ®é¢˜ç›®è§„å®š  ä½ ABCDæ˜¯ä»€ä¹ˆç‰›é©¬
    static String S,T;
    static Map<String,Integer>map=new HashMap<>();//åˆ‡è®°åˆ‡è®°å› ä¸ºæœ‰å¾ˆå¤šæ ·ä¾‹æ‰€ä»¥å¿…é¡»clear
    static Set<String>banks=new HashSet<>();//åŒä¸Š
    int res=0;//å®Œå…¨ä¸è¦static
    public int minMutation(String start, String end, String[] bank) {
        d=new ArrayDeque<>();
        S=start;T=end;
        for(String s:bank){
            banks.add(s);
        }
        d.addLast(S);
        map.put(S,0);
        bfs();
        map.clear();//clear
        banks.clear();//clear
        d.clear();//
        return res;
    }
    void bfs(){
         while(!d.isEmpty()){
        //      int size = d.size();// å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œ æŠŠè¿™ä¸€å±‚æ‰€æœ‰çš„å…ƒç´ éƒ½å–å‡ºæ¥è¿›è¡Œæ“ä½œ
        //     while (size-- > 0) {//æ²¡æœ‰ä¹Ÿå¯ä»¥
            String tmp=d.pollFirst();
            char[] mchs=tmp.toCharArray();
            int step=map.get(tmp);
            for(int i=0;i<8;i++){
                for(char c:chs){
                    if(mchs[i]==c)continue;
                    char[]clone=mchs.clone();
                    clone[i]=c;
                    String sub=String.valueOf(clone);
                    if(!banks.contains(sub))continue;
                    if(map.containsKey(sub))continue;
                    if(sub.equals(T)){res=step+1;return;}
                    map.put(sub,step+1);
                    d.addLast(sub);
                }

            }
     //   }
        }
        res=-1;
        return;
    }
}
```



- æ—¶é—´å¤æ‚åº¦ï¼šä»¤ nä¸º `bank` çš„æ•°ç»„é•¿åº¦ï¼ˆåˆæ³•çŠ¶æ€æ•°ï¼‰ï¼Œå°† `bank` å­˜å…¥ `Set` ç»“æ„å¤æ‚åº¦ä¸º O(n)ï¼Œæ¯ä¸ªçŠ¶æ€ç»è¿‡ä¸€æ­¥æ“ä½œæœ€å¤šæ‹“å±•å‡º C=32 ä¸ªæ–°åŸºå› ï¼ˆå…±æœ‰ 8 ä¸ªä½ç½®ï¼Œæ¯ä¸ªä½ç½®æœ‰ 4ä¸ªé€‰æ‹©ï¼‰ï¼Œ`BFS` è¿‡ç¨‹å¤æ‚åº¦ä¸º O(Câˆ—n)ã€‚æ•´ä½“å¤æ‚åº¦ä¸º O(Câˆ—n)
- ç©ºé—´å¤æ‚åº¦ï¼šO(n)

------

#### åŒå‘ BFS

åŒç†ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ã€ŒåŒå‘ `BFS`ã€è¿›è¡Œæ±‚è§£ã€‚

åŒå‘ `BFS` ä¸å¸¸è§„ `BFS` ç›¸æ¯”ï¼Œèƒ½å¤Ÿæœ‰æ•ˆè§£å†³ã€Œæœç´¢ç©ºé—´çˆ†ç‚¸ã€çš„é—®é¢˜ï¼š

![img](https://pic.leetcode-cn.com/1623894968-XELIvK-image.png)

å¯¹åŒå‘ `BFS` ä¸ç†Ÿæ‚‰çš„åŒå­¦å¯ä»¥çœ‹å‰ç½®ğŸ§€ï¼š[(é¢˜è§£) 127. å•è¯æ¥é¾™](https://leetcode-cn.com/problems/word-ladder/solution/gong-shui-san-xie-ru-he-shi-yong-shuang-magjd/)ã€‚

ä»£ç ï¼š

Java

```java
class Solution {
    static char[] items = new char[]{'A', 'C', 'G', 'T'};
    Set<String> set = new HashSet<>();
    public int minMutation(String S, String T, String[] bank) {
        set.add(S);
        for (String s : bank) set.add(s);
        if (!set.contains(T)) return -1;
        Deque<String> d1 = new ArrayDeque<>(), d2 = new ArrayDeque<>();
        d1.addLast(S); d2.addLast(T);
        Map<String, Integer> m1 = new HashMap<>(), m2 = new HashMap<>();
        m1.put(S, 0); m2.put(T, 0);
        while (!d1.isEmpty() && !d2.isEmpty()) {
            int t = -1;
            if (d1.size() <= d2.size()) t = update(d1, m1, m2);
            else t = update(d2, m2, m1);
            if (t != -1) return t;
        }
        return -1;
    }
    int update(Deque<String> d, Map<String, Integer> cur, Map<String, Integer> other) {
        int m = d.size();
        while (m-- > 0) {
            String s = d.pollFirst();
            char[] cs = s.toCharArray();
            int step = cur.get(s);
            for (int i = 0; i < 8; i++) {
                for (char c : items) {
                    if (cs[i] == c) continue;
                    char[] clone = cs.clone();
                    clone[i] = c;
                    String sub = String.valueOf(clone);
                    if (!set.contains(sub) || cur.containsKey(sub)) continue;
                    if (other.containsKey(sub)) return other.get(sub) + step + 1;
                    d.addLast(sub);
                    cur.put(sub, step + 1);
                }
            }
        }
        return -1;
    }
}
```

- æ—¶é—´å¤æ‚åº¦ï¼šä»¤ nn*n* ä¸º `bank` çš„æ•°ç»„é•¿åº¦ï¼ˆåˆæ³•çŠ¶æ€æ•°ï¼‰ï¼Œå°† `bank` å­˜å…¥ `Set` ç»“æ„å¤æ‚åº¦ä¸º O(n)ï¼Œæ¯ä¸ªçŠ¶æ€ç»è¿‡ä¸€æ­¥æ“ä½œæœ€å¤šæ‹“å±•å‡º C=32ä¸ªæ–°åŸºå› ï¼ˆå…±æœ‰ 8ä¸ªä½ç½®ï¼Œæ¯ä¸ªä½ç½®æœ‰ 4ä¸ªé€‰æ‹©ï¼‰ï¼Œ`BFS` è¿‡ç¨‹å¤æ‚åº¦ä¸º O(Câˆ—n)ã€‚æ•´ä½“å¤æ‚åº¦ä¸º O(Câˆ—n)
- ç©ºé—´å¤æ‚åº¦ï¼šO(n)

------

#### A* ç®—æ³•

è‹¥ä¸è€ƒè™‘ `bank` çš„é™åˆ¶ï¼Œå¯¹äºä¸€ä¸ªç‰¹å®šçŠ¶æ€è€Œè¨€ï¼Œæˆ‘ä»¬å¯ä»¥ä»»æ„é€‰æ‹©ä¸€ä½æ›¿æ¢ä¸º 444 ç±»å­—ç¬¦ä¹‹ä¸€ï¼Œå› æ­¤å¯¹äºä»»æ„çŠ¶æ€ xx*x* è€Œè¨€ï¼Œå…¶ä¸ç›®æ ‡çŠ¶æ€ TT*T* çš„ã€Œç†è®ºæœ€å°è½¬æ¢æ­¥æ•°ã€ä¸ºä¸¤è€…å¯¹åº”ä½ç½®ä¸åŒå­—ç¬¦çš„æ•°é‡ï¼Œè€Œç”±äºå­˜åœ¨ `bank` é™åˆ¶ï¼Œå®é™…æœ€å°æ­¥æ•°å¿…ç„¶æ»¡è¶³ã€Œå¤§äºç­‰äºã€è¯¥ç†è®ºæœ€å°è½¬æ¢æ­¥æ•°ã€‚

åŸºäºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—å½“å‰çŠ¶æ€åˆ°ç›®æ ‡çŠ¶æ€çš„ã€Œç†è®ºæœ€å°è½¬æ¢æ­¥æ•°ã€ä½œä¸ºå¯å‘å¼å‡½æ•°ï¼Œè¿›è¡Œå¯å‘å¼æœç´¢ã€‚

å…·ä½“çš„ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †ï¼‰ç»´æŠ¤æ‰€æœ‰çš„çŠ¶æ€ï¼Œæ¯æ¬¡ä¼˜å…ˆã€Œå¯å‘å€¼ = ç†è®ºæœ€å°è½¬æ¢æ­¥æ•°ã€çš„çŠ¶æ€è¿›è¡Œä¼˜å…ˆå‡ºé˜Ÿæ‹“å±•ã€‚

å¯¹ã€ŒA* ç®—æ³•ã€ä¸äº†è§£çš„åŒå­¦å¯ä»¥çœ‹å‰ç½® ğŸ§€ï¼š[å‘æŒ¥ A* ç®—æ³•æœ€å¤§ä»·å€¼çš„å…³é”®ç‚¹](https://leetcode.cn/link/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU4NDE3MTEyMA%3D%3D%26mid%3D2247489588%26idx%3D1%26sn%3D479e4c0627247ab7e20af7909f2a8b64)ã€‚

ä»£ç ï¼š

Java

```java
class Solution {
    class Node {
        String s;
        int val;
        Node(String _s) {
            s = _s;
            for (int i = 0; i < 8; i++) {
                if (s.charAt(i) != T.charAt(i)) val++;
            }
        }
    }
    static char[] items = new char[]{'A', 'C', 'G', 'T'};
    String S, T;
    public int minMutation(String start, String end, String[] bank) {
        Set<String> set = new HashSet<>();
        for (String s : bank) set.add(s);
        S = start; T = end;
        PriorityQueue<Node> q = new PriorityQueue<>((a,b)->a.val-b.val);
        Map<String, Integer> map = new HashMap<>();
        q.add(new Node(S));
        map.put(S, 0);
        while (!q.isEmpty()) {
            Node node = q.poll();
            char[] cs = node.s.toCharArray();
            int step = map.get(node.s);
            for (int i = 0; i < 8; i++) {
                for (char c : items) {
                    if (cs[i] == c) continue;
                    char[] clone = cs.clone();
                    clone[i] = c;
                    String sub = String.valueOf(clone);
                    if (!set.contains(sub)) continue;
                    if (sub.equals(T)) return step + 1;
                    if (!map.containsKey(sub) || map.get(sub) > step + 1) {
                        map.put(sub, step + 1);
                        q.add(new Node(sub));
                    }
                }
            }
        }
        return -1;
    }
}
```

- æ—¶é—´å¤æ‚åº¦ï¼šå¯å‘å¼æœç´¢åˆ†ææ—¶ç©ºå¤æ‚åº¦æ„ä¹‰ä¸å¤§
- ç©ºé—´å¤æ‚åº¦ï¼šå¯å‘å¼æœç´¢åˆ†ææ—¶ç©ºå¤æ‚åº¦æ„ä¹‰ä¸å¤§

------

#### å»ºå›¾ + DFS

**ç”± `S` å’Œ bank[i]ç»„æˆåˆæ³•ç‚¹é›†ï¼Œä¸”ç‚¹é›†ä¸­ä»»æ„ä¸¤ç‚¹ä¹‹é—´å­˜åœ¨æ— å‘è¾¹çš„å……è¦æ¡ä»¶æ˜¯ï¼šç‚¹ uå’Œç‚¹ væ‰€ä»£è¡¨çš„å­—ç¬¦ä¸­ï¼Œä»…æœ‰ä¸€ä¸ªä½ç½®å­—ç¬¦ä¸åŒã€‚**

å› æ­¤æˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰çš„ç‚¹å­˜å…¥ `list` ä¸­ï¼Œå‡è®¾ `list` é•¿åº¦ä¸º *n*ã€‚åŒæ—¶ä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬äººä¸ºç¡®ä¿ `S` å‡ºç°åœ¨å¤´éƒ¨ï¼ˆç‚¹ç¼–å·ä¸º 1ï¼‰ï¼Œ`T` å‡ºç°åœ¨å°¾éƒ¨ï¼ˆç‚¹ç¼–å·ä¸º *n*ï¼‰ã€‚

éå† `list` è¿›è¡Œå»ºå›¾ï¼ˆå¯¹äºä¸¤å­—ç¬¦ä¸²ä¸­ä»…æœ‰ä¸€ä½ç½®ä¸åŒçš„ç‚¹è¿›è¡Œè¿è¾¹æ“ä½œï¼‰ï¼Œç„¶åè·‘ä¸€éä» 1 åˆ° *n* çš„ `DFS`ã€‚

ç”±äºå›¾ä¸­å¯èƒ½æœ‰ç¯æˆ–æ— è§£ï¼Œå› æ­¤å¿…é¡»ã€Œè®¾å®šä¸€ä¸ªæœ€å¤§æœç´¢æ·±åº¦ã€å¹¶å¢åŠ ã€Œæœ€ä¼˜è§£å‰ªæã€ï¼Œç¡®ä¿æœç´¢è¿‡ç¨‹ç»“æŸã€‚

æœ€å¤§æœç´¢æ·±åº¦çš„è®¾å®šå¯ä»¥åˆ©ç”¨åè¯æ³•ï¼šå¦‚æœ `S` èƒ½å¤Ÿåˆ°è¾¾ `T`ï¼Œé‚£ä¹ˆæœ€ä¼˜è·¯å¾„ä¸­å¿…ç„¶ä¸å­˜åœ¨ç¯ï¼ˆå¦åˆ™å¯ä»¥æŠŠç¯å»æ‰ï¼Œå¾—åˆ°ä¸€æ¡æ›´çŸ­çš„è·¯å¾„ï¼‰ï¼Œå³æœ€ä¼˜è·¯å¾„æ‰€ç»è¿‡çš„ç‚¹çš„æ•°é‡å¿…ç„¶ä¸è¶…è¿‡ *n*ã€‚

ä»£ç ï¼š

Java

```java
class Solution {
    int N = 15, M = 15 * 15 * 2 + 50, idx = 0, loc = 1;
    int[] he = new int[N], e = new int[M], ne = new int[M];
    int n, ans;
    void add(int a, int b) {
        e[idx] = b;
        ne[idx] = he[a];
        he[a] = idx++;
    }
    void dfs(int u, int fa, int depth) {
        if (depth >= ans) return ; // æœ€ä¼˜è§£å‰ªæ
        if (u == n) {
            ans = depth;
            return ;
        }
        for (int i = he[u]; i != -1; i = ne[i]) {
            int j = e[i];
            if (j == fa) continue;
            dfs(j, u, depth + 1);
        }
    }
    public int minMutation(String S, String T, String[] bank) {
        List<String> list = new ArrayList<>();
        list.add(S);
        boolean ok = false;
        for (String s : bank) {
            if (s.equals(S)) continue;
            if (s.equals(T)) {
                ok = true;
                continue;
            }
            list.add(s);
        }
        if (!ok) return -1;
        list.add(T);
        n = list.size();
        ans = n;
        Arrays.fill(he, -1);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i == j) continue;
                int cnt = 0;
                for (int k = 0; k < 8 && cnt <= 1; k++) {
                    if (list.get(i).charAt(k) != list.get(j).charAt(k)) cnt++;
                }
                if (cnt == 1) {
                    add(i + 1, j + 1); add(j + 1, i + 1);
                }
            }
        }
        dfs(1, -1, 0);
        return ans == n ? -1 : ans;
    }
}
```

- æ—¶é—´å¤æ‚åº¦ï¼šä»¤ `bank` çš„é•¿åº¦ä¸º nï¼ˆå³ç‚¹é›†çš„æ•°é‡çº§ä¸º *n*ï¼‰ï¼Œé¢„å¤„ç†å‡º `list` çš„å¤æ‚åº¦ä¸º O(n)ï¼›å»ºå›¾æ“ä½œçš„å¤æ‚åº¦ä¸º O(Câˆ—n2)ï¼Œå…¶ä¸­ C=8 åŸºå› åºåˆ—é•¿åº¦ï¼›`DFS` è¿‡ç¨‹ç”±äºè®¾å®šäº†æœ€å¤§æœç´¢æ·±åº¦ï¼Œå¤æ‚åº¦ä¸º O(n2)ã€‚æ•´ä½“å¤æ‚åº¦ä¸º O(Câˆ—n2)
- ç©ºé—´å¤æ‚åº¦ï¼šæœ€åæƒ…å†µä¸‹ä¸ºå®Œå…¨å›¾ï¼Œå¤æ‚åº¦ä¸º O(n2)O

------

